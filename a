from fastapi import FastAPI, HTTPException, Depends, Security
from fastapi.security import HTTPBasic, HTTPBasicCredentials
from fastapi.responses import JSONResponse
import pandas as pd
import matplotlib.pyplot as plt
import io

app = FastAPI()

security = HTTPBasic()

# Credenciales de acceso
fake_users_db = {
    "username": "password"
}

clientes_df = pd.read_csv("clientes_segmentados.csv", index_col="ID cliente")
productos_mas_vendidos_df = pd.read_csv("productos_mas_vendidos.csv")
productos_menos_vendidos_df = pd.read_csv("productos_menos_vendidos.csv")
resultados_cohorte_df = pd.read_csv("resultados_cohorte.csv")

@app.get("/")
async def obtener_mensaje():
    """
    Mensaje de bienvenida para la API de Eureka.
    """
    return {"message": "¡Bienvenido a la API de Eureka! Esta API proporciona información sobre productos más y menos vendidos, así como el producto más consumido por mes."}


@app.get("/token")
async def login(credentials: HTTPBasicCredentials = Depends(security)):
    """
    Obtener token de autenticación.
    """
    correct_username = fake_users_db.get(credentials.username)
    correct_password = fake_users_db.get(credentials.password)
    if not (correct_username and correct_password and
            correct_username == credentials.username and
            correct_password == credentials.password):
        return JSONResponse(status_code=401, content={"message": "Nombre de usuario o contraseña incorrectos"})
    return {"token": "token_de_eureka"}



@app.get("/clientes/{segmento}")
async def obtener_clientes(segmento: str):
    """
    Obtener clientes por segmento.
    """
    if segmento.lower() not in ["oro", "plata", "bronce"]:
        raise HTTPException(status_code=404, detail="Segmento no válido")

    clientes_segmento = clientes_df[clientes_df["Cliente"] == segmento.capitalize()]
    clientes = clientes_segmento["Nombre"].tolist()
    cantidad = len(clientes)
    porcentaje = (cantidad / len(clientes_df)) * 100

    return {
        "segmento": segmento.capitalize(),
        "clientes": clientes,
        "cantidad": cantidad,
        "porcentaje": f"{porcentaje:.2f}%"
    }

# CRUD - Create
@app.post("/clientes")
async def agregar_cliente(nombre: str, cliente: str):
    """
    Agregar un nuevo cliente.
    """
    if cliente.lower() not in ["oro", "plata", "bronce"]:
        raise HTTPException(status_code=404, detail="Segmento no válido")

    nuevos_datos = pd.DataFrame({"Nombre": [nombre], "Cliente": [cliente.capitalize()]})
    global clientes_df
    clientes_df = pd.concat([clientes_df, nuevos_datos])
    clientes_df.to_csv("clientes_segmentados.csv")
    return {"message": "Cliente agregado exitosamente"}


# CRUD - Read
@app.get("/clientes")
async def obtener_todos_los_clientes():
    """
    Obtener todos los clientes segmentados.
    """
    return clientes_df.to_dict(orient="index")


# CRUD - Update
@app.put("/clientes/{id_cliente}")
async def actualizar_cliente(id_cliente: str, nombre: str, cliente: str):
    """
    Actualizar información de un cliente.
    """
    if id_cliente not in clientes_df.index:
        raise HTTPException(status_code=404, detail="Cliente no encontrado")
    if cliente.lower() not in ["oro", "plata", "bronce"]:
        raise HTTPException(status_code=404, detail="Segmento no válido")

    clientes_df.loc[id_cliente] = [nombre, cliente.capitalize()]
    clientes_df.to_csv("clientes_segmentados.csv")
    return {"message": "Cliente actualizado exitosamente"}


# CRUD - Delete
@app.delete("/clientes/{id_cliente}")
async def eliminar_cliente(id_cliente: str):
    """
    Eliminar un cliente.
    """
    if id_cliente not in clientes_df.index:
        raise HTTPException(status_code=404, detail="Cliente no encontrado")

    clientes_df = clientes_df.drop(id_cliente)
    clientes_df.to_csv("clientes_segmentados.csv")
    return {"message": "Cliente eliminado exitosamente"}



@app.get("/grafica")
async def obtener_grafica():
    """
    Obtener gráfica de la proporción de clientes por segmento.
    """
    counts = clientes_df["Cliente"].value_counts()
    counts.plot(kind="bar")
    plt.xlabel("Segmento")
    plt.ylabel("Cantidad de clientes")
    plt.title("Cantidad de clientes por segmento")
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    # Convertir la gráfica en un archivo de imagen
    img = io.BytesIO()
    plt.savefig(img, format="png")
    img.seek(0)

    return img

@app.get("/producto-mas-consumido")
async def obtener_producto_mas_consumido(año: int, mes: int):
    """
    Obtener el producto más consumido del mes.
    """
    try:
        producto_mas_consumido = resultados_cohorte_df.loc[(resultados_cohorte_df["Año"] == año) &
                                                           (resultados_cohorte_df["Mes"] == mes),
                                                           "Consumido"].iloc[0]
    except IndexError:
        raise HTTPException(status_code=404, detail="No se encontraron datos para el año y mes especificados")

    return {"año": año, "mes": mes, "producto_mas_consumido": producto_mas_consumido}


@app.get("/productos-mas-vendidos")
async def obtener_productos_mas_vendidos():
    """
    Obtener lista de productos más vendidos.
    """
    return productos_mas_vendidos_df.to_dict(orient="records")


@app.get("/productos-menos-vendidos")
async def obtener_productos_menos_vendidos():
    """
    Obtener lista de productos menos vendidos.
    """
    return productos_menos_vendidos_df.to_dict(orient="records")




if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)